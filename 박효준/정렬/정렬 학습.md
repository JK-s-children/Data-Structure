## 버블정렬 (Bubble Sort)
``` swift
func sortBubble() {
    for i in 0..<array.count - 1 {
        for j in 0..<array.count - i - 1 {
            if array[j] > array[j + 1] {
                count += 1
                array.swapAt(j, j + 1)
            }
        }
    }
}
```
- 시간복잡도: O(N^2)
- 두 인접한 데이터 비교
- 앞에 있는 데이터가 뒤에 있는 데이터보다 크면 Swap
- 맨 끝에부터 큰 값으로 채워나감
- 배열의 총 개수 - 1로 설정하고(= 맨 첫 번째 수는 자동으로 제일 적은 값이 들어가기 때문)
(array.count - i - 1)만큼 인접한 두 데이터 비교

## 선택정렬 (Selection Sort)
``` swift
func sortSelection() {
    for stand in 0..<array.count - 1 {
        var minIndex = stand
        for currentIndex in stand + 1..<array.count {
            if array[minIndex] > array[currentIndex] {
                minIndex = currentIndex
            }
        }
        array.swapAt(minIndex, stand)
    }
}
```
- 시간복잡도: O(N^2)
- 배열 중 데이터가 가장 작은 값의 인덱스를 기록함
- 찾은 인덱스와 첫 번째 인덱스의 데이터를 Swap

## 삽입정렬 (Insertion Sort)
``` swift
func sortInsertion() {
    for stand in 1..<array.count {
        for currentIndex in stride(from: stand, to: 0, by: -1) {
            if array[currentIndex] < array[currentIndex - 1] {
                count += 1
                array.swapAt(currentIndex, currentIndex - 1)
            }
        }
    }
}
```
- 시간복잡도: O(N^2)
- 두 번째 요소부터 정렬을 시작함
- 기준이 되는 인덱스로부터 그 앞의 데이터를 모두 비교함
- 이때, 기준 값보다 그 앞의 데이터가 더 크다면 둘을 바꿈